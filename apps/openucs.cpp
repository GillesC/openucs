// Author: Michiel Sandra, Lund University

#include <boost/filesystem/operations.hpp>
#include <uhd/exception.hpp>
#include <uhd/rfnoc/ddc_block_control.hpp>
#include <uhd/rfnoc_graph.hpp>
#include <uhd/utils/safe_main.hpp>
#include <uhd/rfnoc/mb_controller.hpp>
#include <sounder_rx_block_control.hpp>
#include <uhd/rfnoc/block_id.hpp>
#include <boost/program_options.hpp>
#include <uhd/utils/graph_utils.hpp>
#include <uhd/rfnoc/radio_control.hpp>
#include <uhd/types/tune_request.hpp>
#include <uhd/features/discoverable_feature_getter_iface.hpp>
#include <uhd/usrp/dboard_iface.hpp>
#include <chrono>
#include <complex>
#include <csignal>
#include <fstream>
#include <functional>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <thread>
#include <uhd/features/discoverable_feature_getter_iface.hpp>
#include <gpio_power_iface.hpp>
#include <boost/filesystem.hpp>
#include <boost/format.hpp>
#include <uhd/rfnoc/dmafifo_block_control.hpp>
#include <uhd/rfnoc/replay_block_control.hpp>

namespace po = boost::program_options;
namespace fs = boost::filesystem;
using namespace std::chrono_literals;

static bool stop_signal_called = false;
void sig_int_handler(int)
{
    stop_signal_called = true;
}

int UHD_SAFE_MAIN(int argc, char* argv[])
{
    std::signal(SIGINT, &sig_int_handler);

    std::string args, mname, datadir, addr, type, sync;
    double freq, rate, rx_gain, tx_gain;
    uint64_t st = 0;

    int l, p, meas_rate, k, m, spp, ntx, ntx_ext, ntx_tot, nrx;


    // setup the program options
    po::options_description desc("Allowed options");
    // clang-format off
    desc.add_options()
        ("help", "help message")
        ("args", po::value<std::string>(&args), "Args string override (automaticaly generated by default)")
        ("type", po::value<std::string>(&type), "Device type: x410")
        ("addr", po::value<std::string>(&addr), "USRP IP Address")
        ("sync", po::value<std::string>(&sync), "Type of synchronization: external, gpsdo")
        ("freq", po::value<double>(&freq), "RF center frequency in Hz")
        ("rate", po::value<double>(&rate), "RX rate of the radio block")
        ("rx_gain", po::value<double>(&rx_gain), "RX gain")
        ("tx_gain", po::value<double>(&tx_gain), "TX gain")
        ("st", po::value<uint64_t>(&st)->default_value(0), "Start_time (defaults start after 5s)")
        ("k", po::value<int>(&k)->default_value(0), "K")
        ("m", po::value<int>(&m)->default_value(1), "M")
        ("l", po::value<int>(&l)->default_value(1024), "L")
        ("p", po::value<int>(&p)->default_value(2048), "P")
        ("meas_rate", po::value<int>(&meas_rate)->default_value(200), "Channel sampling period")
        ("spp", po::value<int>(&spp)->default_value(256), "Samples per packet")
        ("ntx", po::value<int>(&ntx)->default_value(1), "Number of tx channels on this device")
        ("ntx_ext", po::value<int>(&ntx_ext)->default_value(0), "Number of tx channels on all other devices")
        ("nrx", po::value<int>(&nrx), "Number of rx channels on this device")
        ("mname", po::value<std::string>(&mname)->default_value("meas"), "Measurement name")
        ("datadir", po::value<std::string>(&datadir)->default_value("."), "Data directory")

    ;
    // clang-format on
    po::variables_map vm;
    po::store(po::parse_command_line(argc, argv, desc), vm);
    po::notify(vm);
    

    // print the help message
    if (vm.count("help")) {
        std::cout << "Open USRP channel sounder " << desc << std::endl;
        std::cout << std::endl;
        return EXIT_SUCCESS;
    } 
    
    /************************************************************************
    * Set args string
     ***********************************************************************/
    int nipc = 1;
    if (!vm.count("args")) {
      if (type == "x410") {
        args = str(boost::format("master_clock_rate=500e6, addr=%1%, time_source=%2%, clock_source=%2%") % addr % sync);
        nipc = 4;
      } else if (type == "e320") {
        args = str(boost::format("master_clock_rate=61.44e6, addr=%1%, time_source=%2%, clock_source=%2%") % addr % sync);
      } else if (type == "e310") {
        args = str(boost::format("master_clock_rate=61.44e6, addr=%1%, time_source=%2%") % addr % sync);
      }
    } 

    /************************************************************************
    * Set some private config parameters
     ***********************************************************************/
    ntx_tot = ntx_ext + ntx;
    int nradio;
    if (type == "x410")
      nradio = 2;
    else
      nradio = 1;


    /************************************************************************
    * Create RFNoC graph object:
     ***********************************************************************/
    auto graph = uhd::rfnoc::rfnoc_graph::make(args);
    
    /************************************************************************
     * Initialize all blocks
     ***********************************************************************/
    // Radio
    uhd::rfnoc::block_id_t radio_id[nradio];
    std::shared_ptr<uhd::rfnoc::radio_control> radio_ctrl[nradio];
    for (int i = 0; i < nradio; i++) {
      radio_id[i] = uhd::rfnoc::block_id_t(0, "Radio", i);
      radio_ctrl[i] = graph->get_block<uhd::rfnoc::radio_control>(radio_id[i]);
    }

    // Replay
    uhd::rfnoc::block_id_t replay_id;
    std::shared_ptr<uhd::rfnoc::replay_block_control> replay_ctrl;

    if (ntx > 0) {
      replay_id = uhd::rfnoc::block_id_t(0, "Replay", 0);
      replay_ctrl = graph->get_block<uhd::rfnoc::replay_block_control>(replay_id);
    }

    // SounderRx
    uhd::rfnoc::block_id_t rx_id;
    std::shared_ptr<uhd::rfnoc::sounder_rx_block_control> rx_ctrl;

    if (nrx > 0) {
      rx_id = uhd::rfnoc::block_id_t(0, "SounderRx", 0);
      rx_ctrl = graph->get_block<uhd::rfnoc::sounder_rx_block_control>(rx_id);
    }

    // Check if there is an DDC
    bool has_ddc = graph->has_block(uhd::rfnoc::block_id_t("DDC"));

    // DDC
    uhd::rfnoc::block_id_t ddc_id[nradio];
    std::shared_ptr<uhd::rfnoc::ddc_block_control> ddc_ctrl[nradio];
    if (has_ddc) {
      for (int i = 0; i < nradio; i++){
        ddc_id[i] = uhd::rfnoc::block_id_t(0, "DDC", i);
        ddc_ctrl[i] = graph->get_block<uhd::rfnoc::ddc_block_control> (ddc_id[i]);
      }
    }
    
    
    /************************************************************************
     * Initialize Rx and Tx streamers 
     ***********************************************************************/
    uhd::stream_args_t stream_args(
        "sc16", "sc16"); // We should read the wire format from the blocks

    // Rx streamer
    auto rx_stream = graph->create_rx_streamer(nrx, stream_args);

    // Tx streamer
    auto tx_stream = graph->create_tx_streamer(ntx, stream_args);

    /************************************************************************
     * Connect all blocks
     ***********************************************************************/
    // Transmitter chain 
    for (int i = 0; i < ntx; i++) {
      int rid = (int) floor(i/nradio);
      int j = i % nradio;
      graph->connect(tx_stream, i, replay_id, i);
      graph->connect(replay_id, i, radio_id[rid], j);
    }

    // Receiver chain 
    for (int i = 0; i < nrx; i++) {
      int rid = (int) floor(i/nradio);
      int j = i % nradio;
      if (has_ddc) {
        graph->connect(radio_id[rid], j, ddc_id[rid], j);
        graph->connect(ddc_id[rid], j, rx_id, i);
      } else {
        graph->connect(radio_id[rid], j, rx_id, i);
      }
      graph->connect(rx_id, i, rx_stream, i);
    }
    
    // Print connections and commit graph
    std::cout << "Active connections:" << std::endl;
    for (auto& edge : graph->enumerate_active_connections()) {
        std::cout << "* " << edge.to_string() << std::endl;
    }
    graph->commit();

    /************************************************************************
     * Configure Radio block
     ***********************************************************************/
    // Rx freq
    for (int i = 0; i < nrx; i++) {
      int rid = (int) floor(i/nradio);
      int j = i % nradio;

      // Rx freq
      radio_ctrl[rid]->set_rx_frequency(freq, j);
      
      // Tx freq
      radio_ctrl[rid]->set_tx_frequency(freq, j);
        
      // Rx gain
      radio_ctrl[rid]->set_rx_gain(rx_gain, j);
      
      // Tx gain
      radio_ctrl[rid]->set_tx_gain(tx_gain, j);
    }

    // Print out actual values
    if (nrx > 0) {
    std::cout << "Requesting RX Freq: " << (freq / 1e6) << " MHz..." << std::endl;
    std::cout << "Actual RX Freq: "
              << (radio_ctrl[0]->get_rx_frequency(0) / 1e6) << " MHz..."
              << std::endl
              << std::endl;

    std::cout << "Requesting RX Gain: " << rx_gain << " dB..." << std::endl;
    std::cout << "Actual RX Gain: " << radio_ctrl[0]->get_rx_gain(0) << " dB..."
              << std::endl
              << std::endl;
    }

    if (ntx > 0) {
    std::cout << "Requesting TX Freq: " << (freq / 1e6) << " MHz..." << std::endl;
    std::cout << "Actual TX Freq: " << (radio_ctrl[0]->get_tx_frequency(0) / 1e6)
              << " MHz..." << std::endl
              << std::endl;

    std::cout << "Requesting TX Gain: " << tx_gain << " dB..." << std::endl;
    std::cout << "Actual TX Gain: " << radio_ctrl[0]->get_tx_gain(0) << " dB..."
              << std::endl
              << std::endl;
    }


    // Rate
    std::cout << "Requesting RX Rate: " << (rate / 1e6) << " Msps..." << std::endl;
    for (int i = 0; i < nradio; i++) {
      rate = radio_ctrl[i]->set_rate(rate);
      // TODO DDC and DUC
    }
    std::cout << "Actual RX Rate: " << (rate / 1e6) << " Msps..." << std::endl
              << std::endl;

    std::this_thread::sleep_for(std::chrono::milliseconds(200));
    
    /************************************************************************
     * Configure SounderRx block
     ***********************************************************************/
    int r = floor(rate/meas_rate) - ntx_tot*(p+m*l) + p;
    rx_ctrl->set_ml(m*l/nipc);
    rx_ctrl->set_p(p/nipc);
    rx_ctrl->set_k(k);
    rx_ctrl->set_r(r/nipc);
    rx_ctrl->set_l(l/nipc);
    rx_ctrl->set_a(ntx_tot);
    rx_ctrl->set_pa(spp/nipc);
    rx_ctrl->set_m(m);

    /************************************************************************
     * Configure synchronization
     ***********************************************************************/
    std::cout.precision(10);
    if (sync == "gpsdo") {
      // wait until gps locked
      std::cout << "Waiting for GPS lock ... " << std::endl;
      while (!graph->get_mb_controller()->get_sensor("gps_locked").to_bool()) 
        ;
      while (!graph->get_mb_controller()->get_sensor("ref_locked").to_bool()) 
        ;

      // set GPS time 
      // wait until a full second has passed
      uint64_t last_time = graph->get_mb_controller()->get_sensor("gps_time").to_int();
      uint64_t now_time  = last_time;
      for (int j = 0; j < 10; ++j){
          std::this_thread::sleep_for(std::chrono::milliseconds(100));
          now_time = graph->get_mb_controller()->get_sensor("gps_time").to_int();
          if(now_time > last_time) {
            graph->get_mb_controller(0)->get_timekeeper(0)->set_time_next_pps(uhd::time_spec_t(now_time+1.0));
            std::cout << "Set time to " << now_time+1.0 << std::endl;
          break;
          } 
      }
      
    } else if (sync == "external") {
      std::cout << "Waiting for ref lock ... " << std::endl;
      while (!graph->get_mb_controller()->get_sensor("ref_locked").to_bool()) 
        ;
      
      double temp_time = std::chrono::duration_cast<std::chrono::duration<double>>(
          std::chrono::system_clock::now().time_since_epoch()).count();
      double rest_time = temp_time - floor(temp_time);

      if (rest_time < 0.5) {
        std::this_thread::sleep_for(std::chrono::milliseconds((int)(0.5-rest_time)*1000));
        graph->get_mb_controller()->get_timekeeper(0)->set_time_next_pps(uhd::time_spec_t(ceil(temp_time)));
        std::cout << "Set time to " << ceil(temp_time) << std::endl;
      } else {
        std::this_thread::sleep_for(std::chrono::milliseconds((int)(1.5-rest_time)*1000));
        graph->get_mb_controller()->get_timekeeper(0)->set_time_next_pps(uhd::time_spec_t(ceil(temp_time)+1));
        std::cout << "Set time to " << ceil(temp_time)+1 << std::endl;
      }
    }
   
    // Give some time to set the time
    std::this_thread::sleep_for(std::chrono::milliseconds(1000));

    // If no start time is given, start in 5 seconds
    uhd::time_spec_t ts_now = graph->get_mb_controller()->get_timekeeper(0)->get_time_now();
    if (st == 0)
      st = ts_now.get_full_secs() + 5;
    
    /************************************************************************
    * Create directory for measurement data
     ***********************************************************************/
    fs::path _datadir = datadir;
    std::string measdir  = str(boost::format("%1%_%2%") % mname % st);   
    fs::path _measdir = _datadir / fs::path(measdir);

    if(not boost::filesystem::exists(_measdir))
      boost::filesystem::create_directory(_measdir);

    /************************************************************************
     * Load Tx files and start
     ***********************************************************************/
    if (ntx > 0) {
      const size_t replay_word_size =
          replay_ctrl->get_word_size(); // Size of words used by replay block
      const size_t sample_size = 4; // Complex signed 16-bit is 32 bits per sample

      // a bit messy, need to fix
      std::string tx_fnm;
      std::ifstream tx_ifs[ntx];
      for (int i = 0; i < ntx; i++){
        tx_fnm = str(boost::format("tx%1%.dat") % i);   
        tx_ifs[i].open(tx_fnm.c_str(), std::ifstream::binary);
      }
      
      // Get the file size
      tx_ifs[0].seekg(0, std::ios::end);
      size_t file_size = tx_ifs[0].tellg();
      tx_ifs[0].seekg(0, std::ios::beg);

      // Calculate the number of 64-bit words and samples to replay
      size_t words_to_replay   = file_size / replay_word_size;
      size_t samples_to_replay = file_size / sample_size;

      // Create buffer
      std::vector<std::vector<char>> tx_buffs( ntx , 
          std::vector<char> (samples_to_replay * sample_size)); 

      std::vector<char*> tx_buff_ptrs;
      for (size_t i = 0; i < tx_buffs.size(); i++)
          tx_buff_ptrs.push_back(&tx_buffs[i].front());

      for (int i = 0; i < ntx; i++){
        tx_ifs[i].read(tx_buff_ptrs[i], samples_to_replay * sample_size);
      }

      
      // Configure a buffer in the on-board memory at address 0 that's equal in
      // size to the file we want to play back (rounded down to a multiple of
      // 64-bit words). Note that it is allowed to playback a different size or
      // location from what was recorded.
      uint32_t replay_buff_addr = 0;
      uint32_t replay_buff_size = samples_to_replay * sample_size;

      for (int i = 0; i < ntx; i++){
        replay_ctrl->record(replay_buff_addr+i*replay_buff_size, replay_buff_size, i);
      }

      // Display replay configuration
      std::cout << "Replay file size:     " << replay_buff_size << " bytes (" << words_to_replay
           << " qwords, " << samples_to_replay << " samples)" << std::endl;

      std::cout << "Record base address:  0x" << std::hex
           << replay_ctrl->get_record_offset(0) << std::dec << std::endl;
      std::cout << "Record buffer size:   " << replay_ctrl->get_record_size(0)
           << " bytes" << std::endl;
      std::cout << "Record fullness:      " << replay_ctrl->get_record_fullness(0)
           << " bytes" << std::endl
           << std::endl;

      // Restart record buffer repeatedly until no new data appears on the Replay
      // block's input. This will flush any data that was buffered on the input.
      uint32_t fullness;
      std::cout << "Emptying record buffer..." << std::endl;
      do {
          for (int i = 0; i < ntx; i++){
            replay_ctrl->record_restart(i);
          }

          // Make sure the record buffer doesn't start to fill again
          auto start_time = std::chrono::steady_clock::now();
          do {
              fullness = replay_ctrl->get_record_fullness(0);
              if (fullness != 0)
                  break;
          } while (start_time + 250ms > std::chrono::steady_clock::now());
      } while (fullness);
      std::cout << "Record fullness:      " << replay_ctrl->get_record_fullness(0)
           << " bytes" << std::endl
           << std::endl;

      // Send data to replay (== record the data)
      std::cout << "Sending data to be recorded..." << std::endl;
      uhd::tx_metadata_t tx_md;
      tx_md.start_of_burst = true;
      tx_md.end_of_burst   = true;

      // We use a very big timeout here, any network buffering issue etc. is not
      // a problem for this application, and we want to upload all the data in one
      // send() call.
      size_t num_tx_samps = tx_stream->send(tx_buff_ptrs, samples_to_replay, tx_md, 4*5.0);
      if (num_tx_samps != samples_to_replay) {
          std::cout << "ERROR: Unable to send " << samples_to_replay << " samples (sent "
                << num_tx_samps << ")" << std::endl;
      }

      // Wait for data to be stored in on-board memory
      std::cout << "Waiting for recording to complete..." << std::endl;
      for (int i = 0; i < ntx; i++){
        while (replay_ctrl->get_record_fullness(i) < replay_buff_size) {
            std::this_thread::sleep_for(50ms);
        }
      }

      std::cout << "Record fullness:      " << replay_ctrl->get_record_fullness(0)
           << " bytes" << std::endl
           << std::endl;

    // Start Tx  
    const bool repeat = true;
      std::cout << "Issuing replay command for " << samples_to_replay
           << " samps in continuous mode..." << std::endl;
      uhd::time_spec_t time_spec = uhd::time_spec_t(st+0.0);
      for (int i = 0; i < ntx; i++) {
        replay_ctrl->play(
            replay_buff_addr+replay_buff_size*i, replay_buff_size, i, time_spec, repeat);
      }
    }
    
    std::cout << "I'm here" << std::endl;
    
    /************************************************************************
     * Start Rx 
     ***********************************************************************/
    unsigned long long num_total_samps = 0;
    const size_t samps_per_buff = l*ntx_tot;
    bool overflow_message = true;
    bool continue_on_bad_packet = false;

    uhd::rx_metadata_t md;
    std::vector<std::vector<std::complex<short>>> buffs( 4 , 
        std::vector<std::complex<short>> (samps_per_buff)); 

    std::vector<std::complex<short>*> buff_ptrs;
    for (size_t i = 0; i < buffs.size(); i++)
        buff_ptrs.push_back(&buffs[i].front());

    uhd::stream_cmd_t stream_cmd(uhd::stream_cmd_t::STREAM_MODE_START_CONTINUOUS);
    stream_cmd.num_samps  = size_t(0);
    stream_cmd.stream_now = false;
    stream_cmd.time_spec  = uhd::time_spec_t(st+0.0);

    if (nrx > 0) {
      std::cout << "Press Ctrl + C to stop sounding..." << std::endl;
      std::cout << "Issuing stream cmd" << std::endl;
      rx_stream->issue_stream_cmd(stream_cmd);
    }

    // Reset the time so it starts logging from 0
    st = 0;

    while(not stop_signal_called){

      if (nrx > 0) {
        std::string fname;
        fs::path _filepath;
        std::ofstream ofs[nrx];

        for (int i = 0; i < nrx; i++) {
          fname = str(boost::format("rx_ch%1%_%2%.dat") % i % st);   
          _filepath = _measdir / fs::path(fname); 
          ofs[i].open(_filepath.string().c_str(), std::ofstream::binary);
        }

        for (int j = 0; j < meas_rate; j++){
          if(stop_signal_called) break;

          size_t num_rx_samps = rx_stream->recv(buff_ptrs, samps_per_buff, md, 100.0);
          
          if (md.error_code == uhd::rx_metadata_t::ERROR_CODE_TIMEOUT) {
              std::cout << "Timeout while streaming" << std::endl;
              break;
          }
          if (md.error_code == uhd::rx_metadata_t::ERROR_CODE_OVERFLOW) {
              if (overflow_message) {
                  overflow_message = false;
                  std::cerr
                      << "Got an overflow indication. Please consider the following:\n"
                         "  Your write medium must sustain a rate of "
                      << (rate * sizeof(std::complex<short>) / 1e6)
                      << "MB/s.\n"
                         "  Dropped samples will not be written to the file.\n"
                         "  Please modify this example for your purposes.\n"
                         "  This message will not appear again.\n";
              }
              continue;
          }
          if (md.error_code != uhd::rx_metadata_t::ERROR_CODE_NONE) {
              std::string error = std::string("Receiver error: ") + md.strerror();
              if (continue_on_bad_packet) {
                  std::cerr << error << std::endl;
                  continue;
              } else
                  throw std::runtime_error(error);
          }
        
          for (int i = 0; i < nrx; i++) {
            if (ofs[i].is_open())
              ofs[i].write((const char*) buff_ptrs[i], num_rx_samps * sizeof(std::complex<short>));
          }
          
          num_total_samps += num_rx_samps;
        }

        st +=1;

        for (int i = 0; i < nrx; i++) {
          if (ofs[i].is_open())
            ofs[i].close();
        }

      } // if nrx > 0

    } // while

    // Remove SIGINT handler
    std::signal(SIGINT, SIG_DFL);

    if (nrx > 0) {
      stream_cmd.stream_mode = uhd::stream_cmd_t::STREAM_MODE_STOP_CONTINUOUS;
      std::cout << "Issuing stop stream cmd" << std::endl;
      rx_stream->issue_stream_cmd(stream_cmd);
      
      int num_post_samps = 0;
      do {
          num_post_samps = rx_stream->recv(buff_ptrs, samps_per_buff, md, 3.0);
      } while (num_post_samps and md.error_code == uhd::rx_metadata_t::ERROR_CODE_NONE);
    
    }
    
    if (ntx > 0) {
      for (int i = 0; i < ntx; i++){
        replay_ctrl->stop(i);
      }
    }

    std::cout << "Samples received:  " << num_total_samps << std::endl; 
    std::cout << std::endl << "Done!" << std::endl << std::endl;
    
    return EXIT_SUCCESS;
}
